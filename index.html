<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Hot News</title>
    <script
      src="https://kit.fontawesome.com/a044e4ebee.js"
      crossorigin="anonymous"
    ></script>
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css"
      rel="stylesheet"
      integrity="sha384-GLhlTQ8iRABdZLl6O3oVMWSktQOp6b7In1Zl3/Jr59b6EGGoI1aFkw7cmDA6j6gD"
      crossorigin="anonymous"
    />
  </head>
  <body>
    <header class="container">
      <nav class="navbar navbar-expand-lg">
        <div class="container-fluid align-item-center">
          <a class="navbar-brand" href="#"
            ><span class="text-danger">Hot</span> News</a
          >

          <div class="d-flex justify-content-between" role="search">
            <!-- <p id="news" class="fs-5 me-3 mt-3">News</p> -->
            <button id="news" class="btn fs-5">News</button>
            <button id="blog" class="btn fs-5">Blog</button>
            <!-- <p id="blog" class="fs-5 me-3 mt-3">Blog</p> -->
          </div>
        </div>
      </nav>
      <hr />
    </header>
    <main>
      <section id="blog-section" class="blog mt-5 container d-none">
        <h4>
          What is the difference between
          <span class="bg-body-secondary py-1 px-2">var</span>,
          <span class="bg-body-secondary py-1 px-2">let</span> and
          <span class="bg-body-secondary py-1 px-2">const</span>?
        </h4>
        <h4>Var</h4>
        <p>
          Before the advent of ES6, var declarations ruled. There are issues
          associated with variables declared with var, though. That is why it
          was necessary for new ways to declare variables to emerge. First,
          let's get to understand var more before we discuss those issues.
        </p>
        <h4>Hoisting of var</h4>
        <p>
          Hoisting is a JavaScript mechanism where variables and function
          declarations are moved to the top of their scope before code
          execution.
        </p>
        <h4>Let</h4>
        <p>
          let is now preferred for variable declaration. It's no surprise as it
          comes as an improvement to var declarations. It also solves the
          problem with var that we just covered. Let's consider why this is so.
        </p>
        <h4>Hoisting of let</h4>
        <p>
          Just like var, let declarations are hoisted to the top. Unlike var
          which is initialized as undefined, the let keyword is not initialized.
          So if you try to use a let variable before declaration, you'll get a
          Reference Error.
        </p>
        <h4>Const</h4>
        <p>
          Variables declared with the const maintain constant values. const
          declarations share some similarities with let declarations.
        </p>
        <h4>const declarations are block scoped</h4>
        <p>
          Like let declarations, const declarations can only be accessed within
          the block they were declared.
        </p>
        <h4>const cannot be updated or re-declared</h4>
        <p>
          This means that the value of a variable declared with const remains
          the same within its scope. It cannot be updated or re-declared. So if
          we declare a variable with const, we can neither do this:
        </p>
        <h4>
          What is the main difference between normal function and arrow
          function?
        </h4>
        <p>
          Regular functions created using function declarations or expressions
          are constructible and callable. Since regular functions are
          constructible, they can be called using the new keyword. However, the
          arrow functions are only callable and not constructible, i.e arrow
          functions can never be used as constructor functions.
        </p>
        <h4>.forEach(), .map(), .filter() .... What's the difference?</h4>
        <p>
          .forEach(), .map(), .filter() .... What's the difference? Published
          May 13, 2018Last updated Jun 07, 2018 .forEach: .forEach(), is used to
          execute the same code on every element in an array but does not change
          the array and it returns undefined. Example: In the example below we
          would use .forEach() to iterate over an array of food and log that we
          would want to eat each of them. let food =
          ['mango','rice','pepper','pear']; food.forEach(function(foodItem){
          console.log('I want to eat '+foodItem); }); Running this on your
          console; forEach result .map(): .map() executes the same code on every
          element in an array and returns a new array with the updated elements.
          Example: In the example below we would use .map to iterate over the
          elements of the cost array and divide each element by 10, then assign
          our new array containing the new cost to the variable newCost. let
          cost = [100,400,300,700]; let newCost = cost.map(function(costItem){
          return costItem / 10; }); console.log(newCost); Running this on your
          console; map result .filter(): .filter() checks every element in an
          array to see if it meets a certain criteria and returns a new array
          with the elements that return truthy for the criteria. Example: In the
          example below we would use .filter to return values that are less than
          200. let cost = [100,400,50,40,700]; let smallCost =
          cost.filter(function(costItem){ return costItem < 200 });
          console.log(smallCost); Running this on your console;
        </p>
        <h4>Why template String is used in JavaScript</h4>
        <p>
          Template strings are a powerful feature of modern JavaScript released
          in ES6. It lets us insert/interpolate variables and expressions into
          strings without needing to concatenate like in older versions of
          JavaScript. It allows us to create strings that are complex and
          contain dynamic elements.
        </p>
      </section>
      <section id="news-section" class="news container">
        <div id="category" class="d-flex justify-content-between"></div>
        <!-- spinner start  -->
        <div
          id="spinner"
          class="d-flex justify-content-center mt-3 text-primary d-none"
        >
          <div class="spinner-border" role="status">
            <span class="visually-hidden">Loading...</span>
          </div>
        </div>
        <!-- spinner end  -->
        <div id="show-news" class="mt-5"></div>
        <!-- Modal -->
        <div
          class="modal fade"
          id="exampleModal"
          tabindex="-1"
          aria-labelledby="exampleModalLabel"
          aria-hidden="true"
        >
          <div class="modal-dialog">
            <div class="modal-content">
              <div class="modal-header">
                <h1
                  id="title-news"
                  class="modal-title fs-5"
                  id="exampleModalLabel"
                ></h1>
                <button
                  type="button"
                  class="btn-close"
                  data-bs-dismiss="modal"
                  aria-label="Close"
                ></button>
              </div>
              <div id="main-news" class="modal-body"></div>
              <div class="modal-footer">
                <button
                  type="button"
                  class="btn btn-secondary"
                  data-bs-dismiss="modal"
                >
                  Close
                </button>
              </div>
            </div>
          </div>
        </div>
      </section>
    </main>
    <script
      src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"
      integrity="sha384-w76AqPfDkMBDXo30jS1Sgez6pr3x5MlQ1ZAGC+nuZB+EYdgRZgiwxhTBTkF7CXvN"
      crossorigin="anonymous"
    ></script>
    <script src="js/index.js"></script>
  </body>
</html>
